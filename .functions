#!/usr/bin/env bash

# -------------------------------------------------------------- //
# Functions
# -------------------------------------------------------------- //

down() {
  CURRENT_DIR="$(pwd)";
  cd "$HOME/docker/build-processmaker"
  docker compose down;
  cd "$CURRENT_DIR";
}

logs() {
  CURRENT_DIR="$(pwd)"
  cd "$HOME/docker/build-processmaker"
  docker compose logs -f
  cd "$CURRENT_DIR"
}

runPhpUnit() {
  CURRENT_DIR="$(pwd)"
  cd "$HOME/docker/build-processmaker"
  bash -c "./run-phpunit $*"
  cd "$CURRENT_DIR"
}

switchToNext() {
  CURRENT_DIR="$(pwd)";
  PACKAGES="$HOME/packages/composer/processmaker";

  cd "$PACKAGES";

  for DIRECTORY in $(ls); do
    { cd "/Users/alex/packages/composer/processmaker/$DIRECTORY" && \
        git fetch --all && \
        git checkout next && \
        git pull; }
  done

  cd "$CURRENT_DIR";
  pm packages:status
}

runDumpServer() {
  CURRENT_DIR="$(pwd)";
  cd "$HOME/docker/build-processmaker" 
  docker compose logs -f dump-server;
  cd "$CURRENT_DIR";
}


restartAllDockerComposeServices() {
  CURRENT_DIR="$(pwd)";

  cd "$HOME/docker/build-processmaker"

  if $(docker compose restart artisan web-backend queue scheduler); then
    echo "Restarted processmaker queue, scheduler, and web-backend";
  else
    echo "Failed to restart web-backend, scheduler, or queue";
  fi
  
  cd "$CURRENT_DIR";
}

restartQueueService() {
  CURRENT_DIR="$(pwd)";

  cd "$HOME/docker/build-processmaker";

  if $(docker compose restart queue); then
    echo "Restarted queue";
  else
    echo "Failed to restart queue";
  fi

  cd "$CURRENT_DIR";
}

restartWebService() {
  CURRENT_DIR="$(pwd)";

  cd "$HOME/docker/build-processmaker"

  if $(docker compose restart web-backend); then
    echo "Restarted web-backend";
  else
    echo "Failed to restart web-backend";
  fi

 cd "$CURRENT_DIR";
}

phpFpmContainerId() {
  docker ps | grep "php-fpm" | awk '{ print $1; }';
}

cmd() {
  CURRENT_DIR="$(pwd)";

  cd ~/docker/build-processmaker;

  docker compose exec -it artisan $@;

  cd "$CURRENT_DIR";
}

dockerExec() {
  docker exec -it $1 bash
}

installProcessMakerEnterprise() {
  BRANCH=develop

  if [ ! -z "$1" ]; then
    BRANCH="$1"
  fi

  if pm core:reset -y -t -d "$BRANCH"; then
     pm core:install-packages --branch="$BRANCH";
  fi
}

buildProcessMakerDockerImages() {
  if [ -f ./build-images.sh ]; then
    /bin/bash build-images.sh $@
  else
    echo \"Build script not found\"
  fi
}

##
# Docker Build
##
dockerBuild() {
  DOCKER_BUILDKIT=0 docker image build $@
}

##
# Show available global package updates with homebrew, composer, and npm
##
run_updates() {
  echo "Homebrew updates..."
  brew update --force

  echo "Composer updates..."
  composer global update --optimize-autoloader --no-cache

  echo "oh-my-zsh updates..."
  omz update
}

##
# Removes existing openapitools/openapi-generator-cli images and
# pulls down the correct version, and tags it with a backwards-compatible
# version for use in processmaker/processmaker v4.1.27
##
pmDockerSetup() {
  IMAGE=openapitools/openapi-generator-cli

  flushDocker;

  # Pull down the image version we want and tag it so
  # the processmaker/processmaker@v4.1.27 will use the
  # tagged version which allows compatability on the M1
  docker pull "$IMAGE":v5.1.1
  docker tag "$IMAGE":v5.1.1 "$IMAGE":v4.2.2

  echo "\n"
  echo "Done!"
}

##
# Clear docker's system cache, prune the networks,
# prune/kill/rm containers, aka remove everything but
# the openapi-generator image
##
flushDocker() {
  flushDocker-7e8c113f1ccd;
}



##
# "Internal" function (which then allows us to redirect STDOUT to /dev/null)
# for removing all images, containers (running or not)
##
flushDocker-7e8c113f1ccd() {
  # Don't delete the openapi-generator containers
  OPENAPI_IMAGE="openapitools/openapi-generator-cli"

  # Iterate through and kill each container
  for DOCKER_PID in $(docker ps | grep -v IMAGE | awk '{ print $1; }'); do
    echo "Killing $DOCKER_PID..."
    docker kill "$DOCKER_PID"
  done

  # Remove existing image, except for the
  # openapi-generator image
  for DOCKER_IMAGE in $(docker image ls | grep -v IMAGE | awk '{ print $3; }'); do
    echo "Removing image $DOCKER_IMAGE..."
    docker rmi "$DOCKER_IMAGE" --force
  done

  # Clean up
  echo "Cleaning up..."
  docker system prune --force
  docker volume prune --force
  docker network prune --force

  echo "Done!"
}

##
# Hack-y way of force removing all running containers
##
rmDockerContainers() {
  for DOCKER_CONTAINER in $(docker container ps --quiet); do
    docker container rm "$DOCKER_CONTAINER" --force
  done
}

##
# Hack-y way of getting all running container logs
##
getDockerLogs() {
  for DOCKER_CONTAINER in $(docker container ps --quiet); do
    docker logs --details "$DOCKER_CONTAINER"
  done
}

##
# Use bat under the hood to format/stylize the file contents output
##
tailWithFormatting() {
  tail -f "$1" | bat --paging=never -l log
}

##
# Clone a ProcessMaker GitHub repo
##
gcr() {
  git clone https://github.com/ProcessMaker/"$1".git
  if [ ! -z "$2" ]; then cd "$1" && git checkout "$2" && cd ..; fi
}

##
# Use ffmpeg to convert any found mp4 files in the
# current working directory to GIFs
##
convertVideosToGifs() {
  for f in ./*.mp4; do ffmpeg -i "$f" -vf scale=320:-1 "${f%.*}.gif"; done
}

##
# Clone all repositories for a given GitHub organization
##
cloneAll() {
  # Make the url to the input github organization's repository page.
  ORG_URL="https://api.github.com/orgs/${1}/repos?per_page=200"

  # List of all repositories of that organization (seperated by newline-eol).
  ALL_REPOS=$(curl -s ${ORG_URL} | grep html_url | awk 'NR%2 == 0' | cut -d ':' -f 2-3 | tr -d '",')

  # Clone all the repositories.
  for ORG_REPO in ${ALL_REPOS}; do git clone ${ORG_REPO}.git; done
}

##
# Restart the macOS DNS service
##
killDns() {
  sudo killall -HUP mDNSResponder
  echo "DNS responder service restarted"
}

##
# Stop local, running web services
##
stopWebServicesQuiet() {
  sudo -v
  echo "Stopping dev services..."

  supervisorctl stop all >/dev/null 2>&1
  sudo brew services stop --quiet --all >/dev/null 2>&1
  brew services stop --quiet --all >/dev/null 2>&1

  # Kill supervisor and any running supervised processes
  supervisorctl stop --all --quiet >/dev/null 2>&1

  # Kill any orphaned php processes
  sudo killall -9 php >/dev/null 2>&1
}

##
# Start local web services
##
startWebServices() {
  valet start &
  wait
  brew services run --quiet mysql &
  brew services run --quiet redis &
  brew services run --quiet supervisor &
  wait
  valet services
}
